1. Nothing but the Truth
true

2. Simple Math
4

3. Intro to Strings
"HELLO WORLD"

4. Intro to List
:a :b :c

5. List: conj
'(1 2 3 4)

6. Intro to Vectors
:a :b :c

7. Vectors: conj
[1 2 3 4]

8. Intro to Sets
#{:a :b :c :d}

9. Sets: conj
2

10. Intro to Maps
20

11. Maps: conj
[:b 2]

12. Intro to Sequences

3

13. Sequences: rest
[20 30 40]

14. Intro to Functions
8

15. Double Down
*2

16. Hello World
#(str "Hello, " % \!)

17. Sequences: map
'(6 7 8)

18. Sequences: filter
'(6 7)

19. Last Element
#(nth %1 (- (count %1) 1))

20. Penultimate Element
#(nth % (- (count %) 2))

21. Nth Element
#(first (drop %2 %1))

22. Count a Sequence
#(reduce (fn [i j](inc i)) 0 %)

23. Reverese a Sequence
reduce conj ()

24. Sum It All Up
reduce +

25. Find the odd numbers
filter odd?

26. Fibonacci Sequence
#(take % (map second (iterate (fn [[fst snd]] [snd (+ fst snd)]) [0 1])))

27. Palindrome Detector
#(= (seq %) (reverse %))

28. Flatten a Sequence
#(filter (complement sequential?) (tree-seq sequential? identity %))

29. Get the Caps
#(apply str (re-seq #"[A-Z]" %))

30. Compress a Sequence
#(reverse (reduce (fn [a b] (if (= (first a) b) a (conj a b))) nil %))

31. Pack a Sequence
partition-by identity

32. Duplicate a Sequence
reduce #(conj  %1 %2 %2) []

33. Replicate a Sequence
#(mapcat (partial repeat %2) %1)

34. Implement range
#(take (- %2 %1) (iterate inc %1))

35. Local bindings
7

36. Let it Be
[z 1, y 3, x 7]

37. Regular Expressions
"ABC"

38. Maximum value
(fn [& arg] (reduce #(if (> %1 %2) %1 %2) arg))

39. Interleave Two Seqs
mapcat list

40. Interpose a Seq
#(vec (drop-last (mapcat (partial conj (list %1)) %2)))

41. Drop Every Nth Item
#(vec (apply concat (partition-all (dec %2) %2 %1)))

42. Factorial Fun
#(apply * (range 1 (inc %)))

43. Reverse Interleave
#(apply map list (partition-all %2 %1))

44. Rotate Sequence
#(drop (mod %1 (count %2)) (take (+ (mod %1 (count %2)) (count %2)) (cycle 
%2)))

45. Intro to Iterate
'(1 4 7 10 13)

46. Flipping out
(fn [f]#(f %2 %1))

47. Contain Yourself
4

48. Intro to some
6

49. Split a sequence
#(list (take %1 %2) (drop %1 %2))

50. Split by Type
#(map val (group-by class %))

51. Advanced Destructuring
[1 2 3 4 5]

52. Intro to Destructuring
(vector c e)

53. Longest Increasing Sub-Seq
!!!!!!

54. Partition a Sequence
#(letfn
  [(partition'[n s] 
              (lazy-seq 
               (when 
                 (<= n (count s)) 
                 (cons 
                  (take n s) 
                  (partition' n (drop n s))))))] 
  (partition' %1 %2))

56. Find Distinct Items
(fn [xs]
    (loop [xs' xs result []]
        (if (empty? xs') result
            (recur (remove #(= (first xs') %) xs') (conj result (first 
xs'))))))

57. Simple Recursion
'(5 4 3 2 1)

58. Function Composition
(fn [& fs](letfn [(comp' 
    ([] identity)
    ([f] f)
    ([f g] (fn 
        ([] (f (g)))
        ([& x] (f (apply g x)))))
    ([f g & h] (reduce comp' f (list* g h))))]
  (apply comp' fs)))

59. Juxtaposition
(fn [& f] (fn [& x] (map #(apply %1 x) f)))

60. Sequence Reductions
!!!!!!

61. Map Construction
(comp (partial apply hash-map) (partial mapcat #(list %1 %2)))

62. Re-implement Iterate
(fn [f n](letfn [(itr [x] (lazy-seq (cons x (itr (f x)))))] (itr n)))

63. Group a Sequence
(fn [f ns] (apply merge (map #(hash-map (f (first %1)) (vec %1)) 
(partition-by f (sort-by f ns)))))

64. Intro to Reduce
+

65. Black Box Testing
!!!!!!

66. Greatest Common Divisor
(fn [& ns](apply min (apply concat (take-while #(not (zero? (first %))) 
(iterate (fn[[a b]] (list (rem b a) a)) (sort ns))))))

67. Prime Numbers
(fn [c](take c (filter (fn [n](not-any?  #(zero?  (mod n %1)) (range 2 n))) 
(iterate inc 2))))

68. Recurring Theme
'(7 6 5 4 3)

69. Merge with a Function
!!!!!!

70. Word Sorting
#(sort-by clojure.string/lower-case  (re-seq #"\w+" %))

71. Rearranging Code: ->
last

72. Rearranging Code: ->>
reduce +

73. Analyze a Tic-Tac-Toe Board
!!!!!!

74. Filter Perfect Squares
!!!!!!

75. Euler's Totient Function
!!!!!!

76. Intro to Trampoline
!!!!!!

77. Anagram Finder
!!!!!!

78. Reimplement Trampoline
!!!!!!

79. Triangle Minimal Path
!!!!!!  

80. Perfect Numbers
!!!!!!

81. Set Intersection
(fn [fst snd] (set (filter #(contains? fst %) snd)))

82. Word Chains
!!!!!!

83. A Half-Truth
(fn [& bools] (not (nil? (and (some true? bools) (some false? bools)))))

84. Transitive Closure
!!!!!!

85. Power Set
!!!!!!

86. Happy numbers
!!!!!!

87. nill 
  
88. Symmetric Difference
#(set (concat (apply disj %1 %2) (apply disj %2 %1)))

89. Graph Tour
!!!!!!

90. Cartesian Product
#(set (for [x (vec %1) y (vec %2)] [x y]))

91. Graph Connectivity
!!!!!!

92. Read Roman numerals
!!!!!!

93. Partially Flatten a Sequence
!!!!!!

94. Game of Life
!!!!!!

95. To Tree, or not to Tree
#(letfn [(tree-detect [[a b c :as xs]] (and (= 3 (count xs)) (not 
(sequential? a)) (if (nil? b) true (if (sequential? b) (tree-detect b) 
false)) (if (nil? c) true (if (sequential? c) (tree-detect c) false))))] 
(tree-detect  %))

96. Beauty is Symmetry 
#(letfn [(re-reverse [[root l-node r-node]] 
    (list root
        (if (sequential? r-node) (re-reverse r-node) r-node) 
            (if (sequential? l-node) (re-reverse l-node) l-node)))] 
    (= (second %) (second (re-reverse %))))

97. Pascal's Triangle
(fn [n] (nth (iterate #(mapv (partial apply +) (partition-all 2 1 (cons 0 % 
))) [1]) (dec n)))

98. Equivalence Classes
!!!!!!
